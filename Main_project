---
title: "**Trabalho**"
author: ""
date: "`r format(Sys.time(), '%d de %B de %Y')`"

output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    includes:
      in_header: cod_logo.html
    df_print: kable
    toc_depth: 4
    highlight: monochrome
    theme: paper

editor_options:
  markdown:
    wrap: 72
---








**Universidade Federal do Rio de Janeiro**    
**Instituto de Economia**     
**Curso:** Econometria I - IEE 2025.2    
**Professor:** Vitor Perreira   

###  **Autores:**     
**Matheus Ferreira da Silva Costa**  
**email:** matheus.costa@graduacao.ie.ufrj.br    
**DRE:** _122144910_

**Arthur Moura da Silva**     
**email:**arthurmouradasilva@gmail.com    
**DRE:** _122121629_

**Igor Mato Grosso**    
**email:** igor.silva@graduacao.ie.ufrj.br    
**DRE:** _122150042_

```{r include=FALSE}

# Universidade Federal do Rio de Janeiro 
# Instituto de Economia
# Curso: Econometria - IEE

# Autores: 

# Matheus Ferreira da Silva Costa 
# DRE: 122144910

# Arthur 
# DRE:122121629

# Igor Mato Grosso
# DRE: 122150042




#Carregando pacote# Carregando pacotes prévios (via Pacote Pacman) 
if (!require("pacman")) install.packages("pacman")

pacman::p_load(
  dplyr, ggplot2, stargazer, lmtest, sandwich, car, plotly,
  extrafont, rmdformats, showtext, readxl, purrr, broom,
  lubridate, tibble, spuRs, tibble,knitr, kableExtra, broom, writexl, htmlwidgets
)


options(scipen = 999)

# Questão (5)


# ================================================================
# EXERCÍCIO DE ECONOMETRIA: ANÁLISE DO MERCADO DE TRABALHO BRASILEIRO
# Equação de Mincer para Retornos à Educação
# ================================================================

set.seed(122121629) # (DRE do Arthur)

# ================================================================
# PARTE 1: GERAÇÃO DOS DADOS
# ================================================================

# Tamanho da amostra
n <- 2000

# Gera variáveis demográficas
data <- data.frame(
  # Educação: anos de estudo (4 a 18 anos, média ~9.5)
  education = pmax(4, pmin(18, round(rnorm(n, mean = 9.5, sd = 3.5)))),
  
  # Sexo: 1 = masculino, 0 = feminino (52% homens)
  male = rbinom(n, 1, 0.52),
  
  # Raça: 1 = branco, 0 = preto/pardo (45% brancos)
  white = rbinom(n, 1, 0.45),
  
  # Experiência: anos de experiência (0 a 45)
  experience = pmax(0, pmin(45, round(rnorm(n, mean = 15, sd = 10))))
)

# Gera regiões (distribuição populacional aproximada)
regions <- c("North", "Northeast", "Southeast", "South", "CenterWest")
region_probs <- c(0.09, 0.27, 0.42, 0.14, 0.08)

data$region <- sample(regions, n, replace = TRUE, prob = region_probs)

# Dummies de região (Southeast como referência)
data$north      <- ifelse(data$region == "North", 1, 0)
data$northeast  <- ifelse(data$region == "Northeast", 1, 0)
data$south      <- ifelse(data$region == "South", 1, 0)
data$centerwest <- ifelse(data$region == "CenterWest", 1, 0)

# ================================================================
# PARTE 2: GERAÇÃO DE SALÁRIOS - ERROS HOMOCEDÁSTICOS
# ================================================================

# Parâmetros da equação de Mincer
beta_0        <- 6.8
beta_edu      <- 0.13
beta_male     <- 0.25
beta_white    <- 0.18
beta_exp      <- 0.035
beta_exp2     <- -0.0005

# Efeitos regionais
beta_north      <- -0.15
beta_northeast  <- -0.20
beta_south      <- 0.08
beta_centerwest <- 0.05

# Gera log-salários com erros HOMOCEDÁSTICOS
data$log_wage_homo <- beta_0 +
  beta_edu * data$education +
  beta_male * data$male +
  beta_white * data$white +
  beta_exp * data$experience +
  beta_exp2 * data$experience^2 +
  beta_north * data$north +
  beta_northeast * data$northeast +
  beta_south * data$south +
  beta_centerwest * data$centerwest +
  rnorm(n, mean = 0, sd = 0.35)

# Converte para níveis (salários)
data$wage_homo <- exp(data$log_wage_homo)

# ================================================================
# PARTE 3: GERAÇÃO DE SALÁRIOS - ERROS HETEROCEDÁSTICOS
# ================================================================

# Variância heterocedástica crescente com educação e experiência
error_variance <- 0.25 + 0.015 * data$education + 0.005 * data$experience

# Gera erros heterocedásticos
hetero_errors <- rnorm(n, mean = 0, sd = sqrt(error_variance))

# Log-salários com erros HETEROCEDÁSTICOS
data$log_wage_hetero <- beta_0 +
  beta_edu * data$education +
  beta_male * data$male +
  beta_white * data$white +
  beta_exp * data$experience +
  beta_exp2 * data$experience^2 +
  beta_north * data$north +
  beta_northeast * data$northeast +
  beta_south * data$south +
  beta_centerwest * data$centerwest +
  hetero_errors

# Converte para níveis
data$wage_hetero <- exp(data$log_wage_hetero)

```


```{r setup, include=FALSE}

#Fonte Times New Roman para os graficos via pacote showtext
showtext_auto()
font_add("Times New Roman", regular = "C:/Windows/Fonts/times.ttf")
```

```{html include=FALSE}
<style>
table, th, td {
  font-family: "Times New Roman", serif !important;
}
</style>
```



# **Questão 01** 

## **01.1) Tabela de Estatísticas Descritivas** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.1:</b> Utilizando o pacote stargazer, faça uma tabela de estatísticas descritivas da sua base de dados.Observe a sintaxe do comando stargazer (não esqueça de instalar e carregar o pacote antes de rodá-lo). 

A tabela deverá conter a média, a mediana, o desvio padrão, o valor mínimo, o valor máximo, e o número de observações. Observe que se você está escrevendo em markdown, a tabela deverá ser feita em html. Se for feito no overleaf, a tabela deve ser salva em .tex.

</div>


```{r echo=FALSE, message=FALSE, warning=FALSE}


# Função que calcula estatísticas para uma variável (numérica ou não)
summarise_var <- function(x){
  if(is.numeric(x)){
    tib <- tibble(
      Mean   = mean(x, na.rm = TRUE),
      Median = median(x, na.rm = TRUE),
      SD     = sd(x, na.rm = TRUE),
      Min    = as.character(min(x, na.rm = TRUE)),
      Max    = as.character(max(x, na.rm = TRUE)),
      N      = sum(!is.na(x))
    )
  } else {
    tib <- tibble(
      Mean   = NA_real_,
      Median = NA_real_,
      SD     = NA_real_,
      Min    = as.character(min(x, na.rm = TRUE)),
      Max    = as.character(max(x, na.rm = TRUE)),
      N      = sum(!is.na(x))
    )
  }
  tib
}

# Aplica a todas as colunas e monta a tabela final (uma linha por variável)
tabela_desc <- map_dfr(names(data), ~ {
  varname <- .
  stats <- summarise_var(data[[varname]])
  stats %>% add_column(Variavel = varname, .before = 1)
}, .id = NULL)

# Ajustes de formatação: arredonda números e organiza colunas
tabela_desc <- tabela_desc %>%
  mutate(
    Mean   = round(Mean, 3),
    Median = round(Median, 3),
    SD     = round(SD, 3),
    Min    = ifelse(is.na(as.numeric(Min)), Min, sprintf("%.3f", as.numeric(Min))),
    Max    = ifelse(is.na(as.numeric(Max)), Max, sprintf("%.3f", as.numeric(Max)))
  ) %>%
  dplyr::select(Variavel, Mean, Median, SD, Min, Max, N)

# Exibe com kable
kable(tabela_desc,
      caption = "Tabela 1.1 – Estatísticas Descritivas da Base de Dados",
      digits = 3,
      format = "html") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "condensed"))


```


```{r include=FALSE}
write_xlsx(tabela_desc, "../output/Tabela_1.1.xlsx")
```

## **01.2) Scatterplot: Salário vs Educação** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.2:</b> Utilizando o pacote <i>ggplot2</i>, faça um scatterplot do salário (eixo y) contra educação em anos de estudo. Faça uma regressão linear utilizando o comando <code>lm</code> e plote os valores preditos no mesmo gráfico.<br><br>
Faça o mesmo, agora com o log do salário.
</div>


### 01.2.1) Salário vs Educação {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=TRUE, fig.align='center'}

theme_set(theme_classic())

plot1.2.1 <- ggplot(data, aes(x = education, y = wage_homo)) +
  geom_point(alpha = 0.4) +
  geom_smooth(method = "lm", se = FALSE) +
  
  scale_y_continuous(
    limits = c(0, 50000),
    breaks = seq(5000, 50000, 5000),
    labels = paste0(seq(5, 50, 5), "mil")
  ) +
  
  scale_x_continuous(
    limits = c(4, 18),
    breaks = seq(4, 18, 2)
  ) +
  
  labs(
    title = "Salário vs Educação (anos de estudo)",
    x = "Educação (anos de estudo)",
    y = "Salário (R$)"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "TT Times New Roman"),
    plot.title = element_text(family = "TT Times New Roman", hjust = 0.5, size = 22),
    axis.title = element_text(family = "TT Times New Roman", size = 16),
    axis.text = element_text(family = "TT Times New Roman", size = 16)
  )
plot1.2.1

```

```{r include=FALSE}
ggsave("../output/Imagem_1.2.1.png", plot = plot1.2.1, width = 8, height = 6, dpi = 300)
```

### 01.2.2) Log do Salário vs Educação {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=TRUE, fig.align='center'}
theme_set(theme_classic())

# limites e breaks do eixo y (log do salário) baseados nos dados
ymin <- floor(min(data$log_wage_homo, na.rm = TRUE))
ymax <- ceiling(max(data$log_wage_homo, na.rm = TRUE))
ybreaks <- seq(ymin, ymax, by = 0.5)

plot1.2.2 <- ggplot(data, aes(x = education, y = log_wage_homo)) +
  geom_point(alpha = 0.4) +
  geom_smooth(method = "lm", se = FALSE) +
  
  scale_y_continuous(
    limits = c(ymin, ymax),
    breaks = ybreaks
  ) +
  
  scale_x_continuous(
    limits = c(4, 18),
    breaks = seq(4, 18, 2)
  ) +
  
  labs(
    title = "Log do Salário vs Educação (anos de estudo)",
    x = "Educação (anos de estudo)",
    y = "Log do Salário"
  ) +
  
  theme_minimal() +
  theme(
    text = element_text(family = "TT Times New Roman"),
    plot.title = element_text(family = "TT Times New Roman", hjust = 0.5, size = 22),
    axis.title = element_text(family = "TT Times New Roman", size = 18),
    axis.text = element_text(family = "TT Times New Roman", size = 18)
  )

plot1.2.2
```

```{r include=FALSE}
ggsave("../output/Imagem_1.2.2.png", plot = plot1.2.2, width = 8, height = 6, dpi = 300)
```

## **01.3) Scatterplot: Salário(log) vs Exp.** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.3:</b> Repita mais uma vez o exercício, plotando o log do salário (eixo y) contra a experiência.
</div>


```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.align='center'}


theme_set(theme_classic())

plot1.3 <- ggplot(data, aes(x = experience, y = log_wage_homo)) +
  geom_point(alpha = 0.4) +
  geom_smooth(method = "lm", se = FALSE) +
  
  scale_y_continuous(
    breaks = seq(floor(min(data$log_wage_homo)), 
                 ceiling(max(data$log_wage_homo)), 0.5)
  ) +
  
  scale_x_continuous(
    limits = c(0, 45),
    breaks = seq(0, 45, 5)
  ) +
  
  labs(
    title = "Log do Salário vs Experiência",
    x = "Experiência (anos)",
    y = "Log do Salário"
  ) +
  
  theme_minimal() +
  theme(
    text = element_text(family = "TT Times New Roman"),
    plot.title = element_text(family = "TT Times New Roman", hjust = 0.5, size = 22),
    axis.title = element_text(family = "TT Times New Roman", size = 18),
    axis.text = element_text(family = "TT Times New Roman", size = 18)
  )

plot1.3
```

```{r include=FALSE}
ggsave("../output/Imagem_1.3.png", plot = plot1.3, width = 8, height = 6, dpi = 300)
```

## **01.4) Regressões do log do Salário** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.4:</b> Utilizando o comando <code>lm</code>, rode uma regressão do log do salário em:<br>
• Anos de estudo<br>
• Experiência<br>
• O quadrado da experiência<br>
• Dummies regionais<br>
• Dummy de sexo<br>
• Dummy de raça<br><br>
Caso seja necessário modificar ou criar alguma variável, utilize o pacote <i>dplyr</i>, e não R-base. Note que as dummies já estão prontas; caso fosse necessário criá-las, vocês poderiam transformar a variável categórica em factor, por exemplo:<br>
<code>data$regiao <- relevel(factor(data$regiao), ref = "Southeast")</code>
</div>



```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}


# Criando a variável experiência ao quadrado
data <- data %>%
  mutate(
    experience2 = experience^2
  )

# Rodando a regressão
reg1 <- lm(
  log_wage_homo ~ education + experience + experience2 +
    male + white +
    north + northeast + south + centerwest,
  data = data
)

summary(reg1)

```


```{r include=FALSE}
# salvar resumo da regressão em Excel
reg1_tidy <- tidy(reg1)   # broom gera tabela com coeficientes, erros, p-values
write_xlsx(reg1_tidy, "../output/Tabela_1.4.xlsx")
```

## **01.5) Resultados da Regressão** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.5:</b> Utilizando o pacote <i>stargazer</i>, reporte os resultados da regressão (tabela com coeficientes, erros padrão, níveis de significância, N, R², R² ajustado, etc.). (No RMarkdown use <code>results='asis'</code> no chunk para renderizar a tabela HTML.)
</div>


```{r reg1_model, echo=FALSE}
reg1 <- lm(log_wage_homo ~ education + experience + I(experience^2) +
             north + northeast + south + centerwest +
             male + white, data = data)

```


```{r echo=FALSE, message=FALSE, warning=FALSE, results='asis', fig.align='center'}

stargazer(
  reg1,
  type = "html",
  title = "<span style='font-family:Times New Roman;'>Tabela 1.5 – Resultados da Regressão</span>",
  dep.var.labels = "Log do Salário",
  covariate.labels = c(
    "Educação",
    "Experiência",
    "Experiência²",
    "Região Norte",
    "Região Nordeste",
    "Região Sul",
    "Região Centro-Oeste",
    "Sexo Masculino",
    "Raça Branca"
  ),
  align = TRUE,
  single.row = FALSE,
  no.space = TRUE,
  column.sep.width = "5pt"
)
```


```{r include=FALSE}
#SALVANDO
# Organizar resultados em formato de tabela
reg1_tidy <- tidy(reg1)   # coeficientes, erros padrão, estatísticas t e p-values
reg1_glance <- glance(reg1) # estatísticas do modelo (R², AIC, etc.)

# Salvar em Excel: uma aba com coeficientes e outra com estatísticas do modelo
write_xlsx(
  list(
    Coeficientes = reg1_tidy,
    Estatisticas = reg1_glance
  ),
  path = "../output/Tabela_1.5.xlsx"
)
```

## **01.6) Valores Preditos + Gráfico 3D** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.6:</b> Calcule os valores preditos e plote um gráfico 3D relacionando o log do salário, a experiência e os anos de estudo. Utilize o pacote <i>plotly</i>.
</div>

```{r echo=TRUE, message=FALSE, warning=FALSE}

# 1) Criar valores preditos do modelo
data$pred_logwage <- predict(reg1)

# 2) Criar gráfico 3D com plotly
plot1.6 <- plot_ly(
  data = data,
  x = ~experience,
  y = ~education,
  z = ~pred_logwage,
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 3, opacity = 0.6)
) %>%
  layout(
    title = list(
      text = "Gráfico 3D: Log do Salário Predito vs Experiência e Educação",
      font = list(
        family = "TT Times New Roman",
        size   = 22
      ),
      x = 0.5   # centraliza o título
    ),
    
    scene = list(
      xaxis = list(
        title = "Experiência (anos)",
        titlefont = list(family = "TT Times New Roman", size = 18),
        tickfont  = list(family = "TT Times New Roman", size = 14)
      ),
      yaxis = list(
        title = "Educação (anos de estudo)",
        titlefont = list(family = "TT Times New Roman", size = 18),
        tickfont  = list(family = "TT Times New Roman", size = 14)
      ),
      zaxis = list(
        title = "Log do Salário Predito",
        titlefont = list(family = "TT Times New Roman", size = 18),
        tickfont  = list(family = "TT Times New Roman", size = 14)
      )
    ),

    font = list(family = "TT Times New Roman"))  # fonte global

plot1.6
```


```{r include=FALSE}
saveWidget(plot1.6, "../output/Imagem_1.6.html", selfcontained = TRUE)
```

## **01.7) Histograma dos Resíduos** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.7:</b> Calcule os resíduos da regressão e tire o quadrado dos resíduos. Plote um histograma dos resíduos.
</div>

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center'}


# 1) Calcular resíduos
data <- data %>%
  mutate(
    residuos = resid(reg1),
    residuos2 = residuos^2
  )

# 2) Histograma dos resíduos
plot1.7 <- ggplot(data, aes(x = residuos)) +
  geom_histogram(bins = 30, alpha = 0.7, fill = "grey60", color = "black") +
  labs(
    title = "Histograma dos Resíduos",
    x = "Resíduos",
    y = "Frequência"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "TT Times New Roman"),
    plot.title = element_text(
      family = "TT Times New Roman",
      hjust = 0.5,
      size = 22
    ),
    axis.title = element_text(
      family = "TT Times New Roman",
      size = 16
    ),
    axis.text = element_text(
      family = "TT Times New Roman",
      size = 16
    )
  )

plot1.7 

```

```{r include=FALSE}
ggsave("../output/Imagem_1.7.png", plot = plot1.7, width = 8, height = 6, dpi = 300)
```

## **01.8) Utilizando log_wage_hetero** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.8:</b> Refaça os itens 1.4, 1.5, 1.6 e 1.7 utilizando a variável <code>log_wage_hetero</code>. O que mudou no gráfico dos resíduos contra os anos de estudo? (Inclua os gráficos resíduos vs educação e resíduos² vs educação para comparação.)
</div>

### 1.8.1) Regressões (log_wage_hetero) {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Regressão substituindo log_wage_homo por log_wage_hetero
reg_hetero <- lm(
  log_wage_hetero ~ education + experience + experience2 +
    north + northeast + south + centerwest +
    male + white,
  data = data
)
```

```{r echo=TRUE, message=FALSE, warning=FALSE, results="asis"}

stargazer(
  reg_hetero,
  type = "html",
  title = "Regressão com log_wage_hetero",
  dep.var.labels = "Log do Salário (Heterogêneo)",
  covariate.labels = c(
    "Educação",
    "Experiência",
    "Experiência²",
    "Região Norte",
    "Região Nordeste",
    "Região Sul",
    "Região Centro-Oeste",
    "Sexo Masculino",
    "Raça Branca"
  ),
  digits = 3
)

```

```{r include = FALSE}
# --- Regressão 1.8.1 com log_wage_hetero ---
reg_hetero <- lm(
  log_wage_hetero ~ education + experience + experience2 +
    north + northeast + south + centerwest +
    male + white,
  data = data
)

# Organizar resultados em tabelas
reg_hetero_tidy   <- tidy(reg_hetero)   # coeficientes, erros padrão, p-values
reg_hetero_glance <- glance(reg_hetero) # estatísticas do modelo (R², etc.)

# Salvar em Excel (duas abas)
write_xlsx(
  list(
    Coeficientes = reg_hetero_tidy,
    Estatisticas = reg_hetero_glance
  ),
  path = "../output/Tabela_1.8.xlsx"
)
```

### 1.8.2) Gráfico 3D – Preditos (log_wage_hetero) {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Valores preditos para o modelo hetero
data$pred_hetero <- predict(reg_hetero)

# Gráfico 3D
plot1.8.2 <- plot_ly(
  data = data,
  x = ~experience,
  y = ~education,
  z = ~pred_hetero,
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 3, opacity = 0.6)
) %>%
  layout(
    title = list(
      text = "Gráfico 3D – Preditos (log_wage_hetero)",
      font = list(
        family = "TT Times New Roman",
        size = 22
      ),
      x = 0.5  # centraliza o título
    ),
    
    scene = list(
      xaxis = list(
        title = "Experiência",
        titlefont = list(family = "TT Times New Roman", size = 18),
        tickfont  = list(family = "TT Times New Roman", size = 14)
      ),
      yaxis = list(
        title = "Anos de Estudo",
        titlefont = list(family = "TT Times New Roman", size = 18),
        tickfont  = list(family = "TT Times New Roman", size = 14)
      ),
      zaxis = list(
        title = "Log Salário Predito",
        titlefont = list(family = "TT Times New Roman", size = 18),
        tickfont  = list(family = "TT Times New Roman", size = 14)
      )
    ),

    font = list(family = "TT Times New Roman")
  )
plot1.8.2

```

```{r include=FALSE}
saveWidget(plot1.8.2, "../output/Imagem_1.8.2.html", selfcontained = TRUE)
```

### 1.8.3) Histograma de Residuos - Modelo Hetero {.tabset .tabset-fade}


```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center'}

data <- data %>%
  mutate(
    residuos_hetero = resid(reg_hetero),
    residuos2_hetero = residuos_hetero^2
  )

# Histograma
plot1.8.3 <- ggplot(data, aes(x = residuos_hetero)) +
  geom_histogram(bins = 30, alpha = 0.7, fill = "grey60", color = "black") +
  labs(
    title = "Histograma dos Resíduos – Modelo Hetero",
    x = "Resíduos",
    y = "Frequência"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "TT Times New Roman"),
    plot.title = element_text(
      family = "TT Times New Roman",
      hjust = 0.5,
      size = 22
    ),
    axis.title = element_text(
      family = "TT Times New Roman",
      size = 16
    ),
    axis.text = element_text(
      family = "TT Times New Roman",
      size = 16
    )
  )

plot1.8.3

```


```{r include=FALSE}
ggsave("../output/Imagem_1.8.3.png", plot = plot1.8.3, width = 8, height = 6, dpi = 300)
```

### 1.8.4) Resíduos vs Educação (log_wage_hetero) {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center'}
plot1.8.4 <- ggplot(data, aes(x = education, y = residuos_hetero)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", se = FALSE, color = "blue") +
  labs(
    title = "Resíduos vs Educação – Modelo com log_wage_hetero",
    x = "Educação (anos)",
    y = "Resíduos"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "TT Times New Roman"),
    plot.title = element_text(
      family = "TT Times New Roman",
      hjust = 0.5,
      size = 22
    ),
    axis.title = element_text(
      family = "TT Times New Roman",
      size = 16
    ),
    axis.text = element_text(
      family = "TT Times New Roman",
      size = 16
    )
  )
plot1.8.4

```


```{r include=FALSE}
ggsave("../output/Imagem_1.8.4.png", plot = plot1.8.4, width = 8, height = 6, dpi = 300)
```

### 1.8.5) Resíduos² vs Educação (log_wage_hetero) {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center'}
plot1.8.5<- ggplot(data, aes(x = education, y = residuos2_hetero)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", se = FALSE, color = "red") +
  labs(
    title = "Resíduos² vs Educação – Modelo com log_wage_hetero",
    x = "Educação (anos)",
    y = "Resíduos²"
  ) +
  theme_minimal() +
  theme(
    text = element_text(family = "TT Times New Roman"),
    plot.title = element_text(
      family = "TT Times New Roman",
      hjust = 0.5,
      size = 22
    ),
    axis.title = element_text(
      family = "TT Times New Roman",
      size = 16
    ),
    axis.text = element_text(
      family = "TT Times New Roman",
      size = 16
    )
  )
plot1.8.5

```


```{r include=FALSE}
ggsave("../output/Imagem_1.8.5.png", plot = plot1.8.5, width = 8, height = 6, dpi = 300)
```



### 1.8.6) Análise{.tabset .tabset-fade}

<div style=" background-color:#ffffff; padding:15px; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; text-align: justify; ">

A utilização da variável log_wage_hetero em comparação com log_wage_homo resultou em uma queda expressiva no poder explicativo do modelo, com o R² passando de 0,665 para 0,360. Essa redução indica maior complexidade ou ruído na relação entre as variáveis explicativas e a nova variável dependente. Além disso, os gráficos de resíduos evidenciam heterocedasticidade, confirmando a violação da hipótese de variância constante dos erros.

Em termos das estimativas, os erros‑padrão aumentaram significativamente, reduzindo a precisão estatística e a significância de algumas variáveis, como a Região Centro‑Oeste e a Região Norte. Embora os sinais dos coeficientes tenham se mantido consistentes, os retornos da educação e da experiência apresentaram leves aumentos, enquanto os prêmios salariais de gênero e raça sofreram pequenas reduções. Esses resultados reforçam a necessidade de métodos robustos, como erros‑padrão consistentes ou transformações adequadas, para lidar com a heteroscedasticidade presente nos dados.

</div>

## **01.9) Teste de White** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.9:</b> Faça um teste de White para testar a presença de heterocedasticidade na regressão do item 1.4 quando se utiliza a variável <code>log_wage_homo</code>.<br><br>
Exemplo: <code>library(lmtest); bptest(reg1, ~ fitted(reg1) + I(fitted(reg1)^2))</code>. Reporte o resultado (p-valor, estatística).
</div>

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Teste de White para heterocedasticidade no modelo do item 1.4
white_test <- bptest(reg1, ~ fitted(reg1) + I(fitted(reg1)^2))

# Extrair resultados em data.frame
res_white <- data.frame(
  Estatistica = white_test$statistic,
  Gl          = white_test$parameter,
  Pvalor      = white_test$p.value,
  Metodo      = white_test$method
)

# Salvar em Excel
write_xlsx(res_white, "../output/Tabela_1.9.xlsx")
white_test
```


## **01.10) Teste de White**(log_wage_hetero){.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.10:</b> Repita o teste de White quando rodamos a variável <code>log_wage_hetero</code>.<br><br>
Exemplo: <code>bptest(reg2, ~ fitted(reg2) + I(fitted(reg2)^2))</code>. Reporte o resultado (use <i>stargazer</i> se quiser apresentar estatísticas em tabela).
</div>

```{r echo=TRUE, message=FALSE, warning=FALSE}

# Regressão usando log_wage_hetero
reg2 <- lm(
  log_wage_hetero ~ education + experience + experience2 +
    north + northeast + south + centerwest +
    male + white,
  data = data
)

# Teste de White
white_test_reg2 <- bptest(reg2, ~ fitted(reg2) + I(fitted(reg2)^2))



# Extrair resultados em data.frame
res_reg2 <- data.frame(
  Modelo     = "log_wage_hetero",
  Estatistica = white_test_reg2$statistic,
  Gl          = white_test_reg2$parameter,
  Pvalor      = white_test_reg2$p.value,
  Metodo      = white_test_reg2$method
)

# Salvar em Excel
write_xlsx(res_reg2, "../output/Tabela_1.10.xlsx")

# Mostrar no relatório
white_test_reg2
```


## **01.11) Equação Minceriana** (por FGLS) {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.11:</b> Reestime a equação minceriana por FGLS. Reporte o resultado. As estimativas ficaram mais parecidas com os parâmetros iniciais do DGP?<br><br>
Exemplo prático: estime <code>sigma2_hat <- resid(reg2)^2</code> e depois <code>lm(..., weights = 1/sigma2_hat)</code>.
</div>

```{r echo=TRUE, message=FALSE, warning=FALSE}

# 1. Resíduos ao quadrado do modelo heterocedástico
sigma2_hat <- resid(reg2)^2

# 2. Estimação FGLS usando pesos = 1/sigma2_hat
reg_fgls <- lm(
  log_wage_hetero ~ education + experience + experience2 +
    north + northeast + south + centerwest +
    male + white,
  data = data,
  weights = 1 / sigma2_hat
)

# Salvar resultados da FGLS (1.11) em Excel
reg_fgls_tidy   <- tidy(reg_fgls)    # coeficientes, erros padrão, p-values
reg_fgls_glance <- glance(reg_fgls)  # estatísticas do modelo (R², etc.)

write_xlsx(
  list(
    Coeficientes = reg_fgls_tidy,
    Estatisticas = reg_fgls_glance
  ),
  path = "../output/Tabela_1.11.xlsx"
)

```

### 1.11.1) reg_fgls {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE}
# 3. Resultado
summary(reg_fgls)
```


### 1.11.2) Análise {.tabset .tabset-fade}

<div style=" 
   background-color:#ffffff; 
   padding:15px;  
   border-radius:6px; 
   margin:15px 0; 
   font-family: 'Times New Roman'; 
   text-align: justify; 
   "> 
  
As estimativas obtidas por FGLS apresentam valores muito próximos aos parâmetros iniciais do DGP. Os coeficientes de educação, experiência e experiência ao quadrado retornam praticamente aos valores verdadeiros, enquanto as variáveis de região, sexo e raça também convergem para magnitudes mais consistentes com o modelo gerador dos dados. Os erros padrão tornam-se significativamente menores e a precisão das estimativas aumenta substancialmente. Portanto, o FGLS produz resultados claramente mais alinhados aos parâmetros originais do DGP do que o modelo estimado por OLS com heterocedasticidade. 
</div>



## **01.12) Utilizando Amostra** (n = 200 mil){.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão 1.12:</b> Rode novamente o código de geração dos dados com uma amostra de 200.000 observações. Estime a equação minceriana para <code>log_wage_hetero</code> por OLS e por FGLS. Compare os resultados com os encontrados quando temos apenas 2.000 observações (comente diferenças em coeficientes, erros-padrão e eficiência).
</div>


```{r echo=TRUE, message=FALSE, warning=FALSE}
set.seed(122121629)

N_big <- 200000  # nova amostra

education <- rnorm(N_big, mean = 9.5, sd = 3.3)
experience <- rpois(N_big, lambda = 16)
experience2 <- experience^2

male  <- rbinom(N_big, 1, 0.53)
white <- rbinom(N_big, 1, 0.45)

regions <- c("North", "Northeast", "South", "CenterWest", "Southeast")
region <- sample(regions, N_big, replace = TRUE, prob = c(0.08, 0.27, 0.12, 0.08, 0.45))

north      <- ifelse(region == "North", 1, 0)
northeast  <- ifelse(region == "Northeast", 1, 0)
south      <- ifelse(region == "South", 1, 0)
centerwest <- ifelse(region == "CenterWest", 1, 0)

# Parâmetros estruturais
beta0 <- 6.7
beta1 <- 0.13
beta2 <- 0.035
beta3 <- -0.0005
beta4 <- -0.10
beta5 <- -0.20
beta6 <- 0.10
beta7 <- 0.07
beta8 <- 0.25
beta9 <- 0.20

# Heterocedasticidade artificial
sigma <- exp(0.02 * education)

error_hetero <- rnorm(N_big, 0, sigma)

log_wage_hetero <- beta0 + beta1*education + beta2*experience +
  beta3*experience2 + beta4*north + beta5*northeast +
  beta6*south + beta7*centerwest + beta8*male + beta9*white +
  error_hetero

# Base final
data_big <- data.frame(
  education, experience, experience2,
  male, white, region,
  north, northeast, south, centerwest,
  log_wage_hetero
)

# Estimação por OLS
reg_ols_big <- lm(log_wage_hetero ~ education + experience + experience2 +
                    north + northeast + south + centerwest + male + white,
                  data = data_big)

# Estimação por FGLS (weights = 1/sigma2_hat)
sigma2_hat_big <- resid(reg_ols_big)^2

reg_fgls_big <- lm(log_wage_hetero ~ education + experience + experience2 +
                     north + northeast + south + centerwest + male + white,
                   data = data_big,
                   weights = 1/sigma2_hat_big)

# --- Questão 1.12: OLS ---
reg_ols_big_tidy   <- tidy(reg_ols_big)    # coeficientes, erros padrão, p-values
reg_ols_big_glance <- glance(reg_ols_big)  # estatísticas do modelo (R², etc.)

write_xlsx(
  list(
    Coeficientes = reg_ols_big_tidy,
    Estatisticas = reg_ols_big_glance
  ),
  path = "../output/Tabela_1.12.1.xlsx"
)


# --- Questão 1.12: FGLS ---
reg_fgls_big_tidy   <- tidy(reg_fgls_big)
reg_fgls_big_glance <- glance(reg_fgls_big)

write_xlsx(
  list(
    Coeficientes = reg_fgls_big_tidy,
    Estatisticas = reg_fgls_big_glance
  ),
  path = "../output/Tabela_1.12.2.xlsx"
)
```

### 1.12.1) reg_ols_big {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(reg_ols_big)
```

### 1.12.2) reg_fgls_big {.tabset .tabset-fade}
```{r}
summary(reg_fgls_big)

```

### 1.12.3) Análise{.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
  text-align: justify;
">
Ao ampliar a amostra de 2.000 para 200.000 observações, observa-se um aumento significativo na precisão das estimativas da equação minceriana. Os coeficientes estimados por OLS na amostra grande permanecem próximos aos valores estruturais do DGP, mas os erros-padrão tornam-se muito menores, refletindo maior eficiência estatística. Ainda assim, a heterocedasticidade artificial continua afetando o modelo OLS: o R² permanece baixo e os erros-padrão seguem inflados em comparação ao FGLS, indicando que o aumento do tamanho amostral não elimina o problema causado pela variância não constante dos erros.

Quando utilizamos FGLS na amostra grande, as estimativas tornam-se extremamente precisas. Os coeficientes praticamente coincidem com os parâmetros verdadeiros do DGP e os erros-padrão são reduzidos a valores próximos de zero, revelando forte ganho de eficiência. Além disso, o R² do modelo FGLS aproxima-se de 1, evidenciando que o procedimento corrige adequadamente a heterocedasticidade gerada no processo de simulação. Comparando com os resultados obtidos com apenas 2.000 observações, nota-se que tanto OLS quanto FGLS melhoram em precisão na amostra ampliada, mas o ganho é muito mais expressivo no FGLS, que recupera quase integralmente os parâmetros estruturais e elimina a distorção causada pela variância heterogênea. Portanto, o aumento da amostra reforça a diferença de eficiência entre os dois estimadores e demonstra que FGLS desempenha substancialmente melhor em contextos com heterocedasticidade conhecida ou estimável.
</div>




# **Questão 02: Repasse cambial** 

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">
<b>Questão (a):</b><br><br>

Considere o seguinte modelo para estimar o repasse cambial para os preços do setor escolhido:
<br><br>
&emsp;&emsp;<b>SetorXX<sub>t</sub> = α + β<sub>1</sub> Câmbio<sub>t</sub> + β<sub>2</sub> IBC-Br<sub>t</sub></b>
<br><br>
A regressão será estimada utilizando os dados da base <i>T2dados.xlsx</i>, onde:<br>
• <b>SetorXX</b>: variação percentual mensal de preços do setor analisado;<br>
• <b>Câmbio</b>: variação percentual mensal do câmbio (R$/US$);<br>
• <b>IBC-Br</b>: variação mensal da atividade econômica brasileira.<br><br>

A seguir, estimamos o modelo no R com o pacote <b>lm()</b>:

</div>

```{r include=FALSE}


# LER BASE DE DADOS

dados <- read_excel("../input/T2dados.xlsx")
setores <- paste0("setor", sprintf("%02d", 0:23))

dummies <- c("fev","mar","abr","mai","jun","jul","ago","set","out","nov","dez")

```


## **02.3) Interpretação dos Coeficientes** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">

<b>Questão 02.3:</b> Interprete os coeficientes. Os sinais dos coeficientes estão corretos? Qual é o repasse cambial para os preços?

</div>

```{r include=FALSE}

# IMPORTAR E PREPARAR BASE
caminho <- "../input/T2dados.xlsx"
df <- read_xlsx(caminho)

df <- df %>% 
  rename(data = ...1) %>% 
  mutate(data = as.Date(data, origin = "1899-12-30"))

df <- df %>% mutate(month = factor(month(data)))

df <- df %>% mutate(cambio_lag1 = lag(cambio, 1))

setores <- grep("^setor", names(df), value = TRUE)

# FUNÇÃO PARA ESTIMAR MODELO COM PURRR

rodar_modelo <- function(setor) {
  
  df_temp <- df %>% mutate(y_lag1 = lag(.data[[setor]], 1))
  
  form <- as.formula(
    paste0(setor, " ~ cambio + cambio_lag1 + ibcbr + y_lag1 + month")
  )
  
  mod <- lm(form, data = df_temp)
  
  tibble(
    setor       = setor,
    beta_cambio = coef(mod)["cambio"],
    beta_cambio_lag1 = coef(mod)["cambio_lag1"],
    beta_ibcbr  = coef(mod)["ibcbr"],
    beta_y_lag1 = coef(mod)["y_lag1"],
    p_cambio        = summary(mod)$coef["cambio","Pr(>|t|)"],
    p_cambio_lag1   = summary(mod)$coef["cambio_lag1","Pr(>|t|)"],
    p_ibcbr         = summary(mod)$coef["ibcbr","Pr(>|t|)"],
    p_y_lag1        = summary(mod)$coef["y_lag1","Pr(>|t|)"],
    r2          = summary(mod)$r.squared
  )
}

# RODAR MODELOS COM PURRR

tabela <- purrr::map_dfr(setores, rodar_modelo)


```

### 2.3.1) Tabela 2.3 – Coeficientes Estimados por Setor{.tabset .tabset-fade}


```{r echo=FALSE, message=FALSE, warning=FALSE}

# Arredondar os valores para apresentação
tabela_formatada <- tabela %>%
  mutate(
    beta_cambio       = round(beta_cambio, 4),
    beta_cambio_lag1  = round(beta_cambio_lag1, 4),
    beta_ibcbr        = round(beta_ibcbr, 4),
    beta_y_lag1       = round(beta_y_lag1, 4),
    p_cambio          = scales::pvalue(p_cambio),
    p_cambio_lag1     = scales::pvalue(p_cambio_lag1),
    p_ibcbr           = scales::pvalue(p_ibcbr),
    p_y_lag1          = scales::pvalue(p_y_lag1),
    r2                = round(r2, 4)
  )

# Exibir tabela com kable
kable(
  tabela_formatada,
  caption = "Tabela 2.3 – Coeficientes Estimados por Setor",
  align = "c",
  format = "html"
) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "condensed")
  )


# Salvar tabela formatada em Excel
write_xlsx(
  tabela_formatada,
  path = "../output/Tabela_2.3.xlsx"
)
```

### 2.3.2) Análise{.tabset .tabset-fade}

<div style=" 
   background-color:#ffffff; 
   padding:15px; border-radius:6px; 
   margin:15px 0; 
   font-family: 'Times New Roman'; 
   text-align: justify; 
   ">
Os coeficientes estimados mostram que o repasse cambial para os preços ocorre de forma heterogênea entre os setores. Quando o coeficiente de câmbio é significativo, ele apresenta sinal positivo, conforme esperado economicamente, indicando que uma depreciação do real aumenta os preços setoriais.

Os setores com repasse mais forte e estatisticamente robusto são o setor 03 (β = 0,4443) e o setor 22 (β = 0,3796). Em seguida, há um grupo com repasse relevante, mas um pouco menor: setor 08, setor 07 e setor 06, todos com coeficientes entre 0,19 e 0,24. Setores como 01, 16 e 00 exibem repasse moderado, enquanto o restante apresenta repasse fraco ou não significativo, indicando baixa sensibilidade às variações cambiais.

Quanto ao efeito da atividade econômica (IBC-Br), poucos setores apresentam impacto relevante. O principal é o setor 12, com coeficiente positivo, enquanto o setor 11 mostra coeficiente negativo. Para a maioria, o IBC-Br não exerce influência estatisticamente significativa.

Assim, os sinais estão corretos e o repasse cambial existe, mas é concentrado em alguns setores específicos, especialmente aqueles mais expostos ao comércio internacional.
</div>



## **02.4) Teste Ljung-Box** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">

<b>Questão 02.4:</b> Teste a presença de autocorrelação utilizando o teste Ljung–Box. Quais as hipóteses
nula e alternativa? Qual a sua conclusão para o teste?

</div>
### 2.4.1) Teste Ljung–Box por Setor {.tabset .tabset-fade}

```{r echo=TRUE, message=FALSE, warning=FALSE}

############################################################
# 02.4 — Teste de Autocorrelação Ljung–Box
# Usando os mesmos modelos da Questão 2.3
############################################################

# Reconstruir lista de modelos exatamente como na 2.3
resultados <- lapply(setores, function(s) {
  
  df_temp <- df %>% mutate(y_lag1 = lag(.data[[s]], 1))
  
  form <- as.formula(
    paste0(s, " ~ cambio + cambio_lag1 + ibcbr + y_lag1 + month")
  )
  
  lm(form, data = df_temp)
})

names(resultados) <- setores

############################################################
# Teste Ljung–Box para cada setor
############################################################

ljung <- lapply(setores, function(s) {
  
  mod <- resultados[[s]]
  res <- residuals(mod)
  
  lb <- Box.test(res, lag = 12, type = "Ljung-Box")
  
  tibble(
    setor     = s,
    lb_stat   = lb$statistic,
    lb_pvalue = lb$p.value
  )
}) %>% bind_rows()

############################################################
# Unir com tabela da questão 2.3
############################################################

tabela_ljung <- tabela %>% 
  left_join(ljung, by = "setor")

# Salvar resultados do teste Ljung–Box em Excel
write_xlsx(
  tabela_ljung,
  path = "../output/Tabela_2.4.xlsx"
)


# Exibir tabela final


kable(
  tabela_ljung,
  caption = "Tabela 2.4 – Teste Ljung–Box por Setor",
  digits = 4,
  format = "html"
) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed")
  )


```
### 2.4.2) Análise{.tabset .tabset-fade}

<div style=" 
   background-color:#ffffff; 
   padding:15px; 
   border-radius:6px; 
   margin:15px 0; 
   font-family: 'Times New Roman'; 
   text-align: justify;
">

O teste Ljung–Box foi aplicado aos resíduos dos modelos setoriais estimados na questão 2.3. A hipótese nula do teste (H0) afirma que não há autocorrelação nos resíduos, enquanto a alternativa indica presença de autocorrelação. Dessa forma, valores de p-value inferiores a 0,05 levam à rejeição de H0.

Os resultados mostram heterogeneidade clara entre os setores. Os setores _setor04, setor06, setor08, setor14, setor15, setor21 e setor22_ apresentam p-values abaixo de 0,05, indicando presença significativa de autocorrelação residual. Nesses casos, o modelo não captura completamente a dinâmica temporal do processo de formação de preços.

Por outro lado, a maior parte dos setores apresenta p-values superiores a 0,05, sugerindo ausência de autocorrelação dos resíduos, de modo que a especificação utilizada é suficiente para capturar a estrutura temporal relevante.

</div>

```{r include=FALSE}

# Importação e preparação da base para responder as questões 5, 6 e 7

df <- read_xlsx("../input/T2dados.xlsx")

# Renomear coluna de data
df <- df %>% rename(data = ...1)

# Converter para Date
df$data <- as.Date(df$data, origin = "1899-12-30")

# Criar dummies mensais
df <- df %>% mutate(month = factor(month(data, label = TRUE, abbr = TRUE)))

# Selecionar apenas colunas essenciais: data, cambio, ibcbr, setores e month
setores <- grep("^setor", names(df), value = TRUE)
df <- dplyr::select(df, data, cambio, ibcbr, dplyr::all_of(setores), month)
```




## **02.5) Utilizando Dummies Sazonais** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">

<b>Questão 02.5:</b> Reestime o modelo incluindo dummies sazonais:
SetorXXt = α + β1 cambiot + β2 ibcbrt +
Σ δj Sazonalj.

</div>

```{r}
# Rodar modelos com dummies sazonais
resultados <- list()
for(s in setores){
  form <- as.formula(paste0(s, " ~ cambio + ibcbr + month"))
  resultados[[s]] <- lm(form, data = df)
}
tabela <- lapply(names(resultados), function(s){
  mod <- resultados[[s]]
  sumr <- summary(mod)
  
  # Extrair os coeficientes com cuidado
  coefs <- coef(sumr)
  
  data.frame(
    setor       = s,
    beta_cambio = coefs["cambio","Estimate"],
    p_cambio    = coefs["cambio","Pr(>|t|)"],
    beta_ibcbr  = coefs["ibcbr","Estimate"],
    p_ibcbr     = coefs["ibcbr","Pr(>|t|)"],
    r2          = sumr$r.squared,
    stringsAsFactors = FALSE
  )
}) %>% bind_rows()

# Ranking do repasse cambial
ranking_repasse <- tabela %>%
  dplyr::select(setor, beta_cambio, p_cambio, beta_ibcbr, p_ibcbr, r2) %>%
  arrange(desc(beta_cambio))
# Salvar tabela consolidada (coeficientes por setor)
write_xlsx(
  tabela,
  path = "../output/Tabela_2.5.1.xlsx"
)

# Salvar ranking do repasse cambial
write_xlsx(
  ranking_repasse,
  path = "../output/Tabela_2.5.2.xlsx"
)
```


### 2.5.1) Resultados Consolidados por setor {.tabset .tabset-fade}

<div style=" background-color:#ffffff; padding:15px; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; text-align: justify; ">

A tabela apresenta os resultados consolidados de todos os setores, incluindo os coeficientes estimados para a variação do câmbio (β₁) e da atividade econômica (β₂), os respectivos p-values e o R² de cada modelo setorial.

</div>

```{r echo=FALSE}
tabela
```


### 2.5.2) ranking_repasse {.tabset .tabset-fade}

<div style=" background-color:#ffffff; padding:15px; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; text-align: justify; ">

A tabela reorganiza os mesmos resultados em ordem decrescente do coeficiente do câmbio, destacando os setores em que o repasse cambial é mais intenso. Essa tabela facilita a comparação entre setores e permite identificar rapidamente quais são mais sensíveis às variações cambiais.

</div>
```{r}
ranking_repasse
```

<div>
## **02.6) Interpretando os Coeficientes** {.tabset .tabset-fade}

<div style=" background-color:#ffffff; padding:15px; border-left:4px solid #003366; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; ">

<b>Questão 02.6:</b> Interprete os coeficientes das dummies sazonais e compare a mudança nos demais coeficientes do item (c).

</div>

<div style=" background-color:#ffffff; padding:15px; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; text-align: justify; ">

Após incluir as dummies sazonais, o R² aumentou na maior parte dos setores e os resíduos foram melhores ajustados, causando certas correções nos betas. Os setores onde o repasse cambial sofreu um aumento após a sazonalidade foram: setor00, setor03, setor05, setor06, setor07, setor08, setor12 e setor22. Ou seja, ao inserir esse controle, o modelo revelou um repasse cambial estruturalmente maior do que parecia antes. No caso do setor12, o repasse cambial estava sendo fortemente mascarado pela ausência de dummies sazonais.

Os setores que tiveram reduções nos repasses cambiais com a inserção da sazonalidade foram: setor01, setor02, setor04, setor09, setor20, setor21 e setor23. Contudo, nesses setores, as variações dos coeficientes cambiais foram muito baixas e, em grande parte, os repasses cambiais foram irrelevantes. Ou seja, o repasse cambial diminuiu levemente onde já era baixo.

Nos demais setores, a sazonalidade não alterou significativamente, já que o repasse cambial se manteve baixo tanto no modelo anterior quanto após a inserção da sazonalidade. O IBCBr mantém pouca relevância em muitos setores, indicando que a inflação desses setores responde pouco ao ciclo doméstico, mas responde fortemente ao câmbio.

</div>

## **02.7) Autocorrelação** {.tabset .tabset-fade}

<div style=" background-color:#ffffff; padding:15px; border-left:4px solid #003366; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; ">

<b>Questão 02.7:</b> Teste a presença de autocorrelação utilizando o teste Ljung–Box. Qual a sua conclusão para o teste?

</div>


### 02.7.1) Teste Ljung–Box {.tabset .tabset-fade}

```{r}
ljung <- lapply(names(resultados), function(s){
  
  mod <- resultados[[s]]
  res <- residuals(mod)
  
  lb  <- Box.test(res, lag = 12, type = "Ljung-Box")
  
  data.frame(
    setor     = s,
    lb_stat   = lb$statistic,
    lb_pvalue = lb$p.value
  )
}) %>% bind_rows()

#Juntar Ljung-Box à tabela principal
tabela_ljung <- tabela %>%
  left_join(ljung, by = "setor")

# Salvar resultados do teste Ljung–Box
write_xlsx(
  tabela_ljung,
  path = "../output/Tabela_2.7.xlsx"
)
#Exibir
tabela_ljung

```
### 02.7.1) Análise {.tabset .tabset-fade}

<div style=" background-color:#ffffff; padding:15px; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; text-align: justify; ">

Os setores que apresentaram autocorrelação nos resíduos foram: setor00, setor01, setor04, setor05, setor06, setor08, setor10, setor11, setor12, setor14 e setor15. Nesses casos, rejeita-se a hipótese nula (H₀) de ausência de autocorrelação, já que o p-value < 0,05. Isso indica que os resíduos não são independentes e que a estrutura temporal do modelo pode não estar totalmente adequada.

Por outro lado, os setores sem autocorrelação nos resíduos foram: setor02, setor03, setor07, setor09, setor13, setor16, setor17, setor18, setor19, setor20, setor21, setor22 e setor23. Ou seja, nesses setores, a hipótese nula não foi rejeitada, e a estrutura temporal parece ser adequada, já que o modelo não apresenta autocorrelação estatisticamente detectada.

</div>



```{r include=FALSE}
# Obtendo arquivo para as questões 8 e 9

# Caminho do arquivo
caminho <- "../input/T2dados.xlsx"
df <- read_xlsx(caminho)

# Renomear coluna de data
df <- df %>% rename(data = ...1)

# Converter para Date
df$data <- as.Date(df$data, origin = "1899-12-30")

# Criar dummies sazonais
df <- df %>% mutate(month = factor(month(data)))
```

## **02.8) Variável Dependente Defasada** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">

<b>Questão 02.8:</b> Reestime o modelo incluindo a variável dependente defasada (t–1) e a variável câmbio defasada (t–1):
SetorXXt = α + β1 cambiot + β2 ibcbrt + β3 SetorXXt−1 + β4 cambiot−1 +
Σ δj Sazonalj. 

e responda qual é o impacto total do repasse cambial para os preços.

</div>

### 02.8.1) Estimação com Variável Defasada {.tabset .tabset-fade}

```{r}
# Criar defasagens
df <- df %>%
  mutate(
    cambio_lag1 = dplyr::lag(cambio, 1)
  )

# Estimar modelos com Y(t-1) e câmbio(t-1)
resultados <- list()

for(s in setores){
  
  df <- df %>% mutate(
    y_lag1 = dplyr::lag(.data[[s]], 1)
  )
  
  form <- as.formula(
    paste0(s, " ~ cambio + cambio_lag1 + ibcbr + y_lag1 + month")
  )
  
  resultados[[s]] <- lm(form, data = df)
}

tabela <- lapply(names(resultados), function(s){
  
  mod  <- resultados[[s]]
  sumr <- summary(mod)
  
  data.frame(
    setor            = s,
    beta_cambio      = coef(mod)["cambio"],
    beta_cambio_lag1 = coef(mod)["cambio_lag1"],
    beta_ibcbr       = coef(mod)["ibcbr"],
    beta_y_lag1      = coef(mod)["y_lag1"],
    p_cambio         = coef(sumr)[,"Pr(>|t|)"]["cambio"],
    p_cambio_lag1    = coef(sumr)[,"Pr(>|t|)"]["cambio_lag1"],
    p_ibcbr          = coef(sumr)[,"Pr(>|t|)"]["ibcbr"],
    p_y_lag1         = coef(sumr)[,"Pr(>|t|)"]["y_lag1"],
    r2               = sumr$r.squared,
    row.names        = NULL 
  )
}) %>% bind_rows()

tabela <- tabela %>%
  dplyr::select(setor, beta_cambio, beta_cambio_lag1, beta_ibcbr,
                beta_y_lag1, p_cambio, p_cambio_lag1, p_ibcbr, p_y_lag1, r2)

# Salvar tabela consolidada dos coeficientes (com variáveis defasadas)
write_xlsx(
  tabela,
  path = "../output/Tabela_2.8.1.xlsx"
)


# Exibir tabela consolidada
tabela

```

### 02.8.2) Análise {.tabset .tabset-fade}


<div style=" background-color:#ffffff; padding:15px;border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; ">

Após a reestimação do modelo utilizando a variável dependente defasada e a variável câmbio defasada, os repasses totais do câmbio aos preços, por cada setor, foram os seguintes:

</div>

```{r echo=FALSE}
# Criar tabela dos repasses totais
repasses <- data.frame(
  setor = c("setor00","setor01","setor02","setor03","setor04","setor05","setor06","setor07",
            "setor08","setor09","setor10","setor11","setor12","setor13","setor14","setor15",
            "setor16","setor17","setor18","setor19","setor20","setor21","setor22","setor23"),
  repasse_total = c(0.1426300,0.1741034,0.0191022,0.7902552,0.0246811,0.0829654,0.2536063,
                    0.3158291,0.3520800,-0.0668370,0.0502207,0.0080955,0.2762190,-0.0471328,
                    0.0517589,0.0770033,0.1820876,0.1921303,0.1067352,0.0608764,0.1005746,
                    0.0667441,0.7176265,0.1289453)
)
# Salvar tabela dos repasses totais
write_xlsx(
  repasses,
  path = "../output/Tabela_2.8.2.xlsx"
)
# Exibir em formato kable
knitr::kable(repasses, caption = "Repasses totais do câmbio aos preços por setor", align = "c")

```



## **02.9) Teste Ljung-Box + Breusch-Pagan** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">

<b>Questão 02.9:</b> Teste a presença de autocorrelação utilizando o teste Ljung–Box e teste a presença de heterocedasticidade utilizando o teste Breusch–Pagan. Qual a sua conclusão
para os testes?

</div>
### 02.9.1) Teste Ljung-Box + Breusch-Pagan {.tabset .tabset-fade}

```{r}
# Teste Ljung–Box
ljung <- lapply(names(resultados), function(s){
  
  mod <- resultados[[s]]
  res <- residuals(mod)
  
  lb  <- Box.test(res, lag = 12, type = "Ljung-Box")
  
  data.frame(
    setor     = s,
    lb_stat   = lb$statistic,
    lb_pvalue = lb$p.value
  )
}) %>% bind_rows()

# Teste Breusch–Pagan
bp_tests <- lapply(names(resultados), function(s){
  
  mod <- resultados[[s]]
  
  bp <- bptest(mod)
  
  data.frame(
    setor       = s,
    bp_stat     = bp$statistic,
    bp_pvalue   = bp$p.value
  )
}) %>% bind_rows()

# Juntar resultados em tabela final
tabela_final <- tabela %>%
  left_join(ljung, by = "setor") %>%
  left_join(bp_tests, by = "setor")

write_xlsx(
  tabela_final,
  path = "../output/Tabela_2.9.xlsx"
)

# Exibir tabela final
tabela_final

```

### 02.9.2) Análise {.tabset .tabset-fade}

<div style=" background-color:#ffffff; padding:15px; border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; ">

Os seguintes setores apresentaram <i>p-value</i> < 0,05 no teste de Ljung–Box: <b>setor04</b> (p = 0.0007), <b>setor07</b> (p = 0.0036), <b>setor08</b> (p = 0.0354), <b>setor12</b> (p = 0.0535), <b>setor15</b> (p = 0.0063), <b>setor16</b> (p = 0.0017), <b>setor17</b> (p = 0.0563), <b>setor22</b> (p = 0.0495) e <b>setor23</b> (p = 0.0176).

Todos esses setores apresentaram autocorrelação de resíduos. Contudo, entre todos esses, após o teste Breusch–Pagan, os setores que apresentaram <i>p-value</i> < 0,05 foram: <b>setor03</b> (p = 0.0083), <b>setor07</b> (p = 0.0069) e <b>setor22</b> (p = 0.0192).

Ou seja, apenas esses três apresentaram heterocedasticidade.

</div>










## **02.10) Reestimando o Modelo ** {.tabset .tabset-fade}

<div style="
  background-color:#ffffff;
  padding:15px;
  border-left:4px solid #003366;
  border-radius:6px;
  margin:15px 0;
  font-family: 'Times New Roman';
">

<b>Questão 02.10:</b> Independentemente dos resultados dos testes no item (h), reestime o modelo usando o erro robusto a heterocedasticidade e autocorrelação (HAC). Com relação ao item (h), a significância dos parâmetros mudou?

</div>

### 02.10.2) Restimação usando HAC {.tabset .tabset-fade}

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
# Caminho do arquivo
caminho <- "../input/T2dados.xlsx"
df <- read_xlsx(caminho)

# Renomear coluna de data
df <- df %>% rename(data = ...1)

# Converter para Date
df$data <- as.Date(df$data, origin = "1899-12-30")

# Criar dummies sazonais
df <- df %>% mutate(month = factor(month(data)))



# Criar defasagens
df <- df %>%
  mutate(
    cambio_lag1 = dplyr::lag(cambio, 1)
  )

# lista de setores
setores <- grep("^setor", names(df), value = TRUE)



# Estimar modelos com Y(t-1) e câmbio(t-1)
resultados <- list()

for(s in setores){
  
  df <- df %>% mutate(
    y_lag1 = dplyr::lag(.data[[s]], 1)
  )
  
  form <- as.formula(
    paste0(s, " ~ cambio + cambio_lag1 + ibcbr + y_lag1 + month")
  )
  
  resultados[[s]] <- lm(form, data = df)
}



# Consolidar resultados
tabela <- lapply(names(resultados), function(s){
  
  mod  <- resultados[[s]]
  sumr <- summary(mod)
  
  data.frame(
    setor              = s,
    beta_cambio        = coef(mod)["cambio"],
    beta_cambio_lag1   = coef(mod)["cambio_lag1"],
    beta_ibcbr         = coef(mod)["ibcbr"],
    beta_y_lag1        = coef(mod)["y_lag1"],
    p_cambio           = coef(sumr)[,"Pr(>|t|)"]["cambio"],
    p_cambio_lag1      = coef(sumr)[,"Pr(>|t|)"]["cambio_lag1"],
    p_ibcbr            = coef(sumr)[,"Pr(>|t|)"]["ibcbr"],
    p_y_lag1           = coef(sumr)[,"Pr(>|t|)"]["y_lag1"],
    r2                 = sumr$r.squared
  )
}) %>% bind_rows()



# Teste Ljung–Box
ljung <- lapply(names(resultados), function(s){
  
  mod <- resultados[[s]]
  res <- residuals(mod)
  
  lb  <- Box.test(res, lag = 12, type = "Ljung-Box")
  
  data.frame(
    setor     = s,
    lb_stat   = as.numeric(lb$statistic),
    lb_pvalue = as.numeric(lb$p.value)
  )
  
}) %>% bind_rows()


# Teste Breusch–Pagan
bp_tests <- lapply(names(resultados), function(s){
  
  mod <- resultados[[s]]
  
  bp <- bptest(mod)
  
  data.frame(
    setor       = s,
    bp_stat     = as.numeric(bp$statistic),
    bp_pvalue   = as.numeric(bp$p.value)
  )
  
}) %>% bind_rows()


# Tabela com Ljung–Box
tabela_ljung <- tabela %>% 
  dplyr::left_join(ljung, by = "setor")


# Tabela final com Ljung–Box + Breusch–Pagan
tabela_final <- tabela_ljung %>% 
  dplyr::left_join(bp_tests, by = "setor")


# Erros robustos a heterocedasticidade e autocorrelação (HAC)

hac_results <- lapply(names(resultados), function(s){
  
  mod <- resultados[[s]]
  
  # Estimador HAC (Newey-West)
  hac_vcov <- NeweyWest(mod, lag = 12, prewhite = FALSE)
  
  # Coeficientes com erros-padrão robustos
  coefs_hac <- coeftest(mod, vcov = hac_vcov)
  
  data.frame(
    setor = s,
    beta_cambio_hac        = coefs_hac["cambio", 1],
    se_cambio_hac          = coefs_hac["cambio", 2],
    p_cambio_hac           = coefs_hac["cambio", 4],
    
    beta_cambio_lag1_hac   = coefs_hac["cambio_lag1", 1],
    se_cambio_lag1_hac     = coefs_hac["cambio_lag1", 2],
    p_cambio_lag1_hac      = coefs_hac["cambio_lag1", 4],
    
    beta_ibcbr_hac         = coefs_hac["ibcbr", 1],
    se_ibcbr_hac           = coefs_hac["ibcbr", 2],
    p_ibcbr_hac            = coefs_hac["ibcbr", 4],
    
    beta_y_lag1_hac        = coefs_hac["y_lag1", 1],
    se_y_lag1_hac          = coefs_hac["y_lag1", 2],
    p_y_lag1_hac           = coefs_hac["y_lag1", 4]
  )
}) %>% bind_rows()



# Tabela final com HAC
tabela_final_hac <- tabela_final %>%
  dplyr::left_join(hac_results, by = "setor")

library(writexl)

# Salvar resultados da Questão 2.10 em Excel
write_xlsx(
  tabela_final_hac,
  path = "../output/Tabela_2.10.xlsx"
)

# Exibir
tabela_final_hac

```
### 02.10.2) Análise {.tabset .tabset-fade}


<div style=" background-color:#ffffff; padding:15px;  border-radius:6px; margin:15px 0; font-family: 'Times New Roman'; text-align: justify; ">

Os resultados mostram que o coeficiente do câmbio (β₁) permanece significativo na maior parte dos setores, mesmo após a correção HAC. A estabilidade desse efeito indica que o repasse cambial contemporâneo é uma característica estrutural do comportamento de preços nos setores analisados, e não um artefato gerado por heterocedasticidade ou autocorrelação nos resíduos.

O coeficiente do câmbio defasado (β₄) apresentou a maior sensibilidade ao tratamento robusto. Em diversos setores, a significância observada com erros-padrão tradicionais desaparece quando adotamos HAC, evidenciando que parte da persistência do repasse cambial era sustentada pela autocorrelação dos resíduos.

A adoção de erros HAC revelou que, em alguns setores, o efeito do IBC-Br estava subestimado. Assim, pode-se afirmar que, embora o IBC-Br não seja um determinante amplamente significativo em todos os setores, ele possui relevância estatística robusta em alguns setores.

</div>

# **Questão 03: Tamanho da turma e manipulação das notas na Itália** 


(EM BREVE)
